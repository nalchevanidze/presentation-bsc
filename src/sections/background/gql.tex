\subsection{GraphQL}

\begin{frame}\frametitle{GraphQL}

  \footnotesize
  \begin{block}{What is GraphQL?}
  GraphQL is an application layer framework for solving the efficiency problems of web communication~\cite{gql-iot}. It was developed internally at  Facebook for three years and published in 2016~\cite{initial-analysis-of-gql}. 
  \end{block}

  \begin{block}{GraphQL as current trend}
  Since its first appearance, it has gained a rich open-source ecosystem~\cite{gql-healthcare}, and the trust of companies from various sectors. e.g. (GitHub), entertainment (Netflix), finance (PayPal), travel (KLM), and others~\cite{morph-gql-1}.
  \end{block}

\begin{block}{Typed Query Language}
  GraphQL is a hierarchically structured language with a strongly typed schema~\cite{gql-healthcare}, where the type system (as a public schema) provides a solid contract between client and server and the possibility of errors caused by a part of the invalid request on the client~\cite{real-time-sys-arc-based-on-gql}.
\end{block}

\end{frame}

\begin{frame}\frametitle{Advantages and Disadvantages of GraphQL}

\footnotesize

\begin{block}{Over-Fetching and Under-Fetching}

reduces the number of JSON responses returned by API calls. which interesting for mobile applications, often faced with limited bandwidth and speed~\cite{migrating-to-gql,gql-healthcare}. In the studies showed that GraphQL could significantly improve performance by reducing unnecessary transfer costs and resulted in a significant reduction in energy consumption and transaction delays and even a reduction in response size~\cite{migrating-to-gql,real-time-sys-arc-based-on-gql,gql-iot}.
\end{block}

\begin{block}{API Versioning}

a stable and consistent contract between two systems for information exchange while remaining flexible for future changes~\cite{gql-healthcare}. 

\begin{itemize}
  \item new fields added to a type do not result in client changes~\cite{migrating-to-gql}. 
  \item provides an \expr{@deprecated} annotation for unsupported fields~\cite{migrating-to-gql}. 
\end{itemize}

\end{block}

\begin{block}{Facilitates Rapid Product Development}

GraphQL requires less effort to implement requirements than REST~\cite{rest-vs-gql-controlled-experiment}.

\begin{itemize}
  \item  GraphQL uses familiar syntax and semantics, similar to common programming languages, shortening the learning curve for beginners~\cite{rest-vs-gql-controlled-experiment}.
  \item GraphQL-IDEs enables real-time query validation and auto-completion~\cite{rest-vs-gql-controlled-experiment,migrating-to-gql}.
  \item Introspection frees up servers to support an interface description language and enables clients to explore the REST instantly~\cite{migrating-to-gql}. 
\end{itemize}

\end{block}

% Using GraphQL with Haskell has the following advantages: First, the languages are typed and support union types. Second, GraphQL fields are lazy, concurrent, resolvable functions that fit Haskell's non-strict and concurrent nature~\cite{gql-spec,haskell-homepage}. This way, the developer does not worry about laziness and concurrency and focuses on business logic.


\end{frame}

\begin{frame}\frametitle{Language}

\begin{block}{GraphQL Schema}

GraphQL allows the client to query a domain-specific database represented by a schema. The schema can be defined with a domain-specific language called Schema Definition Language (SDL)~\cite{migrating-to-gql,gql-on-graph-db}.


\end{block}

\begin{block}{GraphQL Queries}

GraphQL provides a query language that is used by clients. Every GraphQL query is defined in this language and sent to the single GraphQL endpoint as a simple string~\cite{migrating-to-gql,real-time-sys-arc-based-on-gql}.
The query is syntactically similar to JSON but follows the server's specific schema instead of arbitrary JSON objects~\cite{gql-on-graph-db,initial-analysis-of-gql}. 



To respond to queries, the developer of a GraphQL server must implement a function for each field of type resolver. These functions return query values from an underlying data structure.  The GraphQL engine calls them during the query and returns their value as a JSON document~\cite{migrating-to-gql,real-time-sys-arc-based-on-gql}. 


\end{block}


\end{frame}

\begin{frame}
\importGQL{schema}{Schema}
\end{frame}

\begin{frame}

\importGQL{query}{Sample GraphQL Query Using the Mythology }

\importJSON{response}{GraphQL Response of the Query}

\end{frame}
