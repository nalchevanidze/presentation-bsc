\subsection{GraphQL}

\begin{frame}\frametitle{GraphQL}

  \begin{block}{What is GraphQL?}
    \enquote{GraphQL is a query language for APIs}~\cite{gql-spec}. It was developed internally at  Facebook for three years and published in 2016~\cite{initial-analysis-of-gql}. 
  \end{block}

  \begin{block}{GraphQL as a current trend}
    It has a rich open-source ecosystem and the trust of companies in various industries such as GitHub, Netflix, PayPal, and others~\cite{morph-gql-1,gql-healthcare}.
  \end{block}

\begin{block}{Typed Query Language}
  It is a strongly typed language. The type system provides a solid contract between client and server and eliminates the possibility of errors caused by part of the invalid request~\cite{real-time-sys-arc-based-on-gql}.
\end{block}

\end{frame}

\begin{frame}\frametitle{Advantages and Disadvantages of GraphQL}

% reduces unnecessary transmission costs.which interesting for mobile applications, often faced with limited bandwidth and speed~\cite{migrating-to-gql,real-time-sys-arc-based-on-gql,gql-iot}
\begin{block}{Performance and efficiency improvement}
\begin{itemize}
  \item Under-Fetching: reduces  numbers of API calls~\cite{migrating-to-gql}.
  \item Over-Fetching : reduction in response size~\cite{migrating-to-gql}.
\end{itemize}
\end{block}

\begin{block}{API Versioning}
% a stable and consistent contract between two systems for information exchange while remaining flexible for future changes~\cite{gql-healthcare}. 
\begin{itemize}
  \item new fields added to a type do not result in client changes~\cite{migrating-to-gql}. 
  \item provides an \expr{@deprecated} annotation for unsupported fields~\cite{migrating-to-gql}. 
\end{itemize}

\end{block}

\begin{block}{Facilitates Rapid Product Development}

% GraphQL requires less effort to implement requirements than REST~\cite{rest-vs-gql-controlled-experiment}.

\begin{itemize}
  \item  Familiar syntax and semantics~\cite{rest-vs-gql-controlled-experiment}.
  \item GraphQL-IDEs enables real-time query validation and auto-completion~\cite{rest-vs-gql-controlled-experiment,migrating-to-gql}.
  \item Introspection enables clients to explore the REST instantly~\cite{migrating-to-gql}. 
\end{itemize}

\end{block}

% Using GraphQL with Haskell has the following advantages: First, the languages are typed and support union types. Second, GraphQL fields are lazy, concurrent, resolvable functions that fit Haskell's non-strict and concurrent nature~\cite{gql-spec,haskell-homepage}. This way, the developer does not worry about laziness and concurrency and focuses on business logic.

\end{frame}

\begin{frame}\frametitle{GraphQL Language Components}

\begin{block}{Schema Language}

GraphQL allows the client to query a domain-specific database represented by a schema. The schema can be defined with a domain-specific language called Schema Definition Language (SDL)~\cite{migrating-to-gql,gql-on-graph-db}.

\end{block}

\begin{block}{Query Language}

GraphQL provides a query language syntactically similar to JSON but follows the server's specific schema instead of arbitrary JSON objects~\cite{gql-on-graph-db,initial-analysis-of-gql}. 

\end{block}

\begin{block}{Resolver Functions}

Queries are processed by resolver functions which return query values from an underlying data structure  ~\cite{migrating-to-gql,real-time-sys-arc-based-on-gql}.

\end{block}


\end{frame}

\begin{frame}
\importGQL{schema}{Schema}
\end{frame}

\begin{frame}

\importGQL{query}{Sample GraphQL Query Using the Mythology }

\importJSON{response}{GraphQL Response of the Query}

\end{frame}
