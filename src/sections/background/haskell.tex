\subsection{Haskell}
\begin{frame}\frametitle{Haskell}

Haskell is a non-strict, purely functional language with static typing and algebraic data types. Many developers think that Haskell programs look nice~\cite{history-of-haskell}.

\begin{block}{Haskell is lazy}
    % Laziness is a primary concern in Haskell's design. 
    Haskell is a non-strict semantic language; lazy evaluation is just a technique to implement it~\cite{history-of-haskell}.
\end{block}

\begin{block}{Haskell is pure}
The lazy evaluation requires a pure design since a function call can no longer guarantee the reliable execution of the side-effects~\cite{history-of-haskell}.
Haskell abstracts side effects with monads, which allowes compiler to determine impure and pure operations, the Haskell language can use specific optimizations, but developer can specify computation execution order~\cite{history-of-haskell}.
\end{block}

\end{frame}

\begin{frame}\frametitle{Algebraic Data Types and Records}

An algebraic data type is the sum of one or more alternatives, where each alternative is a product of zero or more fields~\cite{history-of-haskell}. 
        
\importHS{maybe}{Algebraic Data Types~\cite{history-of-haskell}}

The record system provides syntactic sugar for what might otherwise be written using ordinary, positional, algebraic data type declarations~\cite{lw-ext-records}. 

\importHSFragment{records}{0}{4}{Haskell Record}

\end{frame}

\begin{frame}\frametitle{Record Values}

Records greatly simplify programming with data structures that have many components. Since the individual components are accessed by name, the order of the fields is not critical~\cite{lw-ext-records}.

\importHSFragment{records}{6}{10}{Haskell Record Values}

Algebraic data types and records and are not extensible. Once a data type is declared, its declaration cannot be extended by adding or removing data constructors or fields~\cite{hlist,lw-ext-records,trees-that-grow}. 

\end{frame}

% \begin{frame}\frametitle{Monads}

% Haskell abstracts side effects with monads. monads are formed by a type constructor \expr{M} and a pair of functions, \expr{return} and \expr{>>=}~\cite{history-of-haskell,essence-of-fp}. The type \expr{M a} is a computation that returns a value of type \expr{a} and possibly performs some side effects~\cite{history-of-haskell}. The purpose of \expr{return} and \expr{>>=} is to push a value into computation and to evaluate a computation, yielding a value~\cite{essence-of-fp}.

% Since the monad allows the compiler to determine impure and pure operations, the Haskell language can use specific optimizations. However, the developer still has the freedom to define their execution order~\cite{history-of-haskell}.

% \end{frame}

\begin{frame}\frametitle{Datatype-Generic Programming}
    
Datatype-generic programming enables writing single functions that address various cases and types.~\cite{derivable-type-classes}. 
It increases program reliability, reduces code duplication, while guaranteeing safety~\cite{datatype-generic-programming,optimizing-generics}.

\importHS{generics}{Generic Deriving}

\end{frame}