\section{Evaluation}

\begin{frame}[allowframebreaks]\frametitle{Evaluation}


\begin{itemize}
  \li{Maintainability}
  \begin{itemize}
  
    \li{Low Boilerplate and Familiarity} We use a code-first approach and derive the API from native Haskell types based on data-generic programming. The approach is familiar and reduces boilerplate.

    \li{Modularity}
    The library architecture divides the functionalities into separate, coherent packages. Parameterized resolver types facilitate modular API definitions.

  \end{itemize}
  \li{Reliability}
  \begin{itemize}
    \li{Type Safety} 
      \begin{enumerate}
  
        \li{Deterministic deriving} The mapping rules cover all Haskell algebraic data types.
  
        \li{Resolver validity} The Haskell compiler reports any value mismatch at compile time.
        
        \li{Schema validity} We ensure compile-time validity of the schema based on Template Haskell. 
      
      \end{enumerate}
  
    \li{Complience with GraphQL Specifications} The library meets all the critical parts of the specifications. However, we use of \expr{Int} instead of \expr{Int32}. Moreover, interfaces and directives are still not fully implemented. 
  
  \end{itemize}

  \li{Efficiency} we used the type \expr{Text} instead of \expr{String}. The library is lazy and only executes the resolvers necessary for the query. 

\end{itemize}
\end{frame}

\begin{frame}\frametitle{Comparison}

Other Haskell libraries provide more extensibility in schema definition than our approach. Besides, the argument chain definitions of the GraphQL API are more flexible than Haskell records for small sets of arguments. However, implementing resolvers for these schemas in our library is simpler because users receive more meaningful error messages, and field values are irrelevant. Besides, our approach is more intuitive and requires less experience than the type-level approach.

There are other libraries in various languages that also have datatype-generic programming to derive GraphQL APIs. However, since we are using Haskell, we have automatically obtained Haskell's lazy and pure nature, which matches the lazy resolvable nature of GraphQL fields. This way, Haskell developers do not need to explicitly consider concurrency and laziness and focus on business logic. 

\end{frame}
