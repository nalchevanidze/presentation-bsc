%!TEX root = ../../../../main.tex

\section{Design Decisions} 

\begin{frame}\frametitle{Design Decisions}
\begin{alertblock}{Code-First Approach}  

This approach generates the schema and validates the resolver types simultaneously, whereby a single type change automatically updates the resolver types and the GraphQL schema, making API maintenance easier.

\end{alertblock}

\begin{alertblock}{Embeded Domain Specific Language Based on Datatype-Generic Programming}  

native language syntax with domain-specific semantics, users can focus on domain-specific problems~\cite{edsl-modeling}. futhermore increases familiarity.

datatype-generic programming eliminates boilerplate code by encouraging the programmer to avoid implementing tedious and high-maintenance boilerplate code~\cite{scrap-your-boilerplate}.


\end{alertblock}

\begin{alertblock}{Monadic Resolvers} 

Since all side effects and behavioral extensions in Haskell are performed with monads, field resolvers will be monadic functions. 
Moreover, resolver monad will be a monad transformer. 

\end{alertblock}


\begin{alertblock}{Parameterized Resolver Types}

One of our requirements the modularity, states that type definitions must be independent of GraphQL operations. i.e., the same GraphQL resolver type definition can be used for mutation and query operations. However, the data type must allow query operations only for query resolvers and mutation operations only for mutation resolvers. This can be achieved by parametric polymorphism, where the type parameter determines the allowed operations. For example,  data type \expr{data Type m = Type \{ resolver :: m Value\}} with parameter \expr{m} can construct query and mutation resolvers, where the type \expr{Type Q} constructs resolver \expr{resolver :: Q Value} with query operations. on the other hand, the type \expr{Type M} constructs resolver \expr{resolver :: M Value} with mutation operations.

\end{alertblock}
\end{frame}