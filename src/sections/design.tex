%!TEX root = ../../../../main.tex

\section{Design Decisions} 

\begin{frame}\frametitle{Design Decisions}
\begin{alertblock}{Code-First Approach}  

This approach generates the schema and validates the resolver types simultaneously, whereby a single type change automatically updates the resolver types and the GraphQL schema, making API maintenance easier.

\end{alertblock}

\begin{alertblock}{EDSL Based on Datatype-Generic Programming}  

The library will represent EDSL based on datatype-generic programming, with the approach inspired by Aeson. This decision targets the maintainability requirement. On the first hand, since the edsl is hosted in another language and uses its syntax but provides domain-specific semantics, users can focus on domain-specific problems and reduces maintenance costs~\cite{edsl-modeling}. On the other hand, datatype-generic programming eliminates boilerplate code by encouraging the programmer to avoid implementing tedious and high-maintenance boilerplate code that is typically required to deal with complex data structures~\cite{scrap-your-boilerplate}.
Furthermore, deriving the schema directly from data types provides a familiar abstraction.

\end{alertblock}

\begin{alertblock}{Monadic Resolvers} 


Since all side effects (e.g., reading data from the database) and behavioral extensions in Haskell are performed with monads, field resolvers will be monadic functions. Moreover, resolver monad will be a monad transformer  that will allow Haxl or similar libraries to solve n+1 selects problem  and other efficiency problems. As a result, the library can create efficient APIS.  Note that the final build APIs efficiency depends primarily on the particular developer skills. However, with this approach, we provide a tool to facilitate it. 

\end{alertblock}


\begin{alertblock}{Parameterized Resolver Types}

One of our requirements the modularity, states that type definitions must be independent of GraphQL operations. i.e., the same GraphQL resolver type definition can be used for mutation and query operations. However, the data type must allow query operations only for query resolvers and mutation operations only for mutation resolvers. This can be achieved by parametric polymorphism, where the type parameter determines the allowed operations. For example,  data type \expr{data Type m = Type \{ resolver :: m Value\}} with parameter \expr{m} can construct query and mutation resolvers, where the type \expr{Type Q} constructs resolver \expr{resolver :: Q Value} with query operations. on the other hand, the type \expr{Type M} constructs resolver \expr{resolver :: M Value} with mutation operations.

\end{alertblock}
\end{frame}