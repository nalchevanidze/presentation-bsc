%!TEX root = ../../../main.tex

\subsection{Mapping Rules}

\begin{frame}\frametitle{Mapping Built-in Types}
\begin{itemize}
  \li{Wrapping Types}
  \begin{itemize}
    \li{Non-Null} inverse mapping with Maybe
    \li{List} List
  \end{itemize}
  \li{Scalar Types}
  \begin{itemize}
    \li{Int} Int
    \li{Float} Double
    \li{String} Text
    \li{Boolean} Bool
    \li{ID}  defined custom data type ID 
  \end{itemize}
\end{itemize}
\end{frame}

\begin{frame}\frametitle{Mapping Enums}

enum types describe the set of possible independent, unique values~\cite{gql-spec}.

\importHS{enum}{GraphQL Enum in Haskell}

\importGQL{enum}{GraphQL Enum}

\end{frame}

\begin{frame}\frametitle{Mapping Input Object And Field Arguments}

A GraphQL input objects and arguments are is a sets of labeled input values~\cite{gql-spec}. They resemble single constructor Haskell records. 

\importHS{input-object}{GraphQL Input Object in Haskell}
\importGQL{input-object}{Input Object Deity}

\end{frame}
\begin{frame}[allowframebreaks]\frametitle{Mapping Objects}

GraphQL objects are a set of named fields, where fields themselves consist of argument and return type~\cite{gql-spec}. We represent the object types with parameterized records, where the record fields can take function types. This technique allows types to be defined independently of the resolver operations, and the concrete operations can be passed recursively from parent to child. 

\importHS{object-type}{GraphQL Object in Haskell}

\importGQL{object-type}{GraphQL Object in Haskell}

\end{frame}

\begin{frame}[allowframebreaks]\frametitle{Unions}

GraphQL unions represent an object, one of the possible alternative object types, but do not provide guaranteed fields between them~\cite{gql-spec}. 

% While in GraphQL, we only refer to the object type in the list of possible types, in Haskell, we put each of them into a specific constructor. Furthermore, in Haskell, we can create alternative objects only with constructors without defining their types.

\importHS{union}{Union Types}
\begin{itemize}
  \item we unpack constructors, where the name is the concatenation of the type constructor name and the referencing type name. for rest we generate new constructors object.
  \item since GraphQL does not supports empty objects we add every empty object unit field.
\end{itemize}

\importGQL{union}{Union Types}

\end{frame}

% \begin{frame}\frametitle{Determining GraphQL Types in Haskell}
% Compiler applies the following rules with a given execution order to achieve deterministic derivation.
% \begin{enumerate}
%   \li{Scalar, Wrapper, Interface} Derive scalar, wrapper, interface if the type has explicitly specified associated kinds. 
%   \li{Field Arguments} Derive field arguments if the type is used as an argument of the object field. 
%   \li{Enum} Derive enum if all data type constructors are empty.
%   \li{Object} Derive object if the type has a single non-empty constructor, and its parent \footnote{Type A is the parent type of type B if it has a field that refers to type B} is Object or Union. 
%   \li{InputObject} Derive input object if the type has a single non-empty constructor, and its parent is InputObject or Field Arguments.
%   \li{Union} Derive Union if the type has multiple constructors and its parent is Object or Union.
%   \li{Fail} All other types are not supported.
% \end{enumerate}
% \end{frame}
