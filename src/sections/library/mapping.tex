%!TEX root = ../../../main.tex

\subsection{Mapping Rules}

\begin{frame}\frametitle{Mapping Built-in Types}
\begin{itemize}
  \li{Wrapping Types}
  \begin{itemize}
    \li{Non-Null} inverse mapping with Maybe
    \li{List} List
  \end{itemize}
  \li{Scalar Types}
  \begin{itemize}
    \li{Int} Int
    \li{Float} Double
    \li{String} Text
    \li{Boolean} Bool
    \li{ID}  defined custom data type ID 
  \end{itemize}
\end{itemize}
\end{frame}

\begin{frame}\frametitle{Mapping Type Definitions}

\begin{itemize}
  \li{Enums} data types with empty alternatives.
  \li{Input object and field arguments} data types with non-empty single constructors (records). 
  \li{Objects} We represent the object types with parameterized records, where the record fields can take function types. With this technique, types can be defined independently of the resolution operations, and the concrete operations can be passed recursively from parent to child. 
  \li{Unions} data type with multiple alternatives, where at least one alternative is non-empty.
  \begin{itemize}
    \item we create a new object for each alternative.
    \item we unpack constructors, where the name is the concatenation of the type constructor name and the referencing type name. 
    \item we assign to each empty alternate unit field.
  \end{itemize}
\end{itemize}

\end{frame}

