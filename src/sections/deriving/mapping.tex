%!TEX root = ../../main.tex

\subsection{Mapping Rules}

% \begin{frame}\frametitle{Mapping Rules}

% % The underlying entity of every GraphQL schema is a type. Thereby there are six types of named type definitions and two wrapping types~\cite{gql-spec}. 
% \footnotesize
% \begin{itemize}

%   \li{Positional Constructors} GraphQL fields must always have names~\cite{gql-spec}. 
%   That why we assume that a constructor without field selectors is enumerated like an array.
  
%   \importHS{positional-cons}{Positional Constructors}

%   \li{Unit Type} The unit type indicates the absence of a specific value and serves as a placeholder when no other value exists or is needed~\cite{fsharp-unit}. GraphQL does not provide it~\cite{gql-spec}. 

%   \importGQL{unit-type}{GraphQL Unit Type Definition}

% \end{itemize}
% \end{frame}

\begin{frame}\frametitle{Mapping Wrapping Types}

\begin{itemize}

  \li{Non-Null} GraphQL types are nullable by default: e.g., a scalar string can return either zero or a string value. The non-null type wraps another type and means that the resulting value will never be null~\cite{gql-spec}.


  \li{List} GraphQL List is a collection of homogeneous elements, where the elements are ordered and serialized according to their type~\cite{gql-spec}. 
\end{itemize}

\end{frame}

\begin{frame}\frametitle{Mapping Scalars}

Scalar types represent primitive leaf values in a GraphQL type system. They can be represented as strings. GraphQL offers built-in scalar and enables users to extend the type system with additional scalars with their semantic meaning~\cite{gql-spec}.

Since scalar types have no structural representation, we will impose no restriction and allow any type to represent a scalar type if it has appropriate parse and serialization methods.

\begin{itemize}

  \item Int: Int
  %  This scalar type represents a signed numeric 
    32-bit non-fractional value~\cite{gql-spec}. 

  \item Float: Double
  %  GraphQL-Float represents signed fractions with double precision~\cite{gql-spec}

  \item String: Text
  %  GraphQL String is a regular UTF-8 string for text data~\cite{gql-spec}. Haskell represents strings through the built-in list type. It allows the programmer to use the polymorphic list combinations for complex string manipulations.
  % However, it is also extremely inefficient. An alternative to String is the type Text, which is an array-based string representation that is faster and more compact than String~\cite{string-vs-text,string-types-alexeyshmalko,string-types-fpcomplete,hackage-data-text}. 
  \item Boolean: Bool
  % Since this represents typical Boolean values (true and false)~\cite{gql-spec}, it is represented as a type Bool.
  \item ID:  defined custom data type ID 
  % is a unique identifier that should always be serialized as a String (although it is often numeric)~\cite{gql-spec}. Accordingly, we declare a new data type ID with parse and serialization implementations that meet this specification.
\end{itemize}

\end{frame}

\begin{frame}\frametitle{Mapping Enums}

enum types describe the set of possible independent, unique values~\cite{gql-spec}. They correspond to the algebraic data type with empty fields. The type is only represented as an enum if all its constructors are empty.

\importHS{enum}{GraphQL Enum}
\importGQL{enum}{GraphQL Enum}

\end{frame}

\begin{frame}\frametitle{Mapping Input Object And Field Arguments}

A GraphQL input objects and arguments are is a sets of labeled input values~\cite{gql-spec}. They resemble single constructor Haskell records. 

\importHS{input-object}{GraphQL Input Object in Haskell}
\importGQL{input-object}{Input Object Deity}

\end{frame}
\begin{frame}[allowframebreaks]\frametitle{Mapping Objects}

GraphQL objects are a set of named fields, where fields themselves consist of argument and return type~\cite{gql-spec}. We represent the object types with parameterized records, where the record fields can take function types. This technique allows types to be defined independently of the resolver operations, and the concrete operations can be passed recursively from parent to child. 

\importHS{object-type}{GraphQL Object in Haskell}

\importGQL{object-type}{GraphQL Object in Haskell}

\end{frame}

\begin{frame}[allowframebreaks]\frametitle{Unions}

GraphQL unions represent an object, one of the possible alternative object types, but do not provide guaranteed fields between them~\cite{gql-spec}. 

% While in GraphQL, we only refer to the object type in the list of possible types, in Haskell, we put each of them into a specific constructor. Furthermore, in Haskell, we can create alternative objects only with constructors without defining their types.

\importHS{union}{Union Types}
\begin{itemize}
  \item we unpack constructors, where the name is the concatenation of the type constructor name and the referencing type name. for rest we generate new constructors object.
  \item since GraphQL does not supports empty objects we add every empty object unit field.
\end{itemize}

\importGQL{union}{Union Types}

\end{frame}

% \begin{frame}\frametitle{Determining GraphQL Types in Haskell}
% Compiler applies the following rules with a given execution order to achieve deterministic derivation.
% \begin{enumerate}
%   \li{Scalar, Wrapper, Interface} Derive scalar, wrapper, interface if the type has explicitly specified associated kinds. 
%   \li{Field Arguments} Derive field arguments if the type is used as an argument of the object field. 
%   \li{Enum} Derive enum if all data type constructors are empty.
%   \li{Object} Derive object if the type has a single non-empty constructor, and its parent \footnote{Type A is the parent type of type B if it has a field that refers to type B} is Object or Union. 
%   \li{InputObject} Derive input object if the type has a single non-empty constructor, and its parent is InputObject or Field Arguments.
%   \li{Union} Derive Union if the type has multiple constructors and its parent is Object or Union.
%   \li{Fail} All other types are not supported.
% \end{enumerate}
% \end{frame}
