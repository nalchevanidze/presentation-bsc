\begin{frame}[noframenumbering]\frametitle{Mapping Positional Constructors}

GraphQL fields must always have names~\cite{gql-spec}. That why we assume that a constructor without field selectors is enumerated like an array.
  
\importHS{positional-cons}{Positional Constructors}

\end{frame}

\begin{frame}[noframenumbering]\frametitle{Datatype-Generic Programming}
    
  Datatype-generic programming enables writing single functions that address various cases and types.~\cite{derivable-type-classes}. 
  It increases program reliability, reduces code duplication while guaranteeing safety~\cite{datatype-generic-programming,optimizing-generics}.
  
  \importHS{generics}{Generic Deriving}
      
  The generic derivation represents all types and values by generic representation types. The user can convert any types to their generic representation, operate on them, and convert them back to their original types~\cite{optimizing-generics, ghc-generics}.
  
  \end{frame}

\begin{frame}[noframenumbering]\frametitle{Monads}

Haskell abstracts side effects with monads. monads are formed by a type constructor \expr{M} and a pair of functions, \expr{return} and \expr{>>=}~\cite{history-of-haskell,essence-of-fp}. The type \expr{M a} is a computation that returns a value of type \expr{a} and possibly performs some side effects~\cite{history-of-haskell}. The purpose of \expr{return} and \expr{>>=} is to push a value into computation and to evaluate a computation, yielding a value~\cite{essence-of-fp}.

Since the monad allows the compiler to determine impure and pure operations, the Haskell language can use specific optimizations. However, the developer still has the freedom to define their execution order~\cite{history-of-haskell}.

\end{frame}

\begin{frame}[noframenumbering]\frametitle{Determining GraphQL Types in Haskell}
Compiler applies the following rules with a given execution order to achieve deterministic derivation.
\begin{enumerate}
  \li{Scalar, Wrapper, Interface} Derive scalar, wrapper, interface if the type has explicitly specified associated kinds. 
  \li{Field Arguments} Derive field arguments if the type is used as an argument of the object field. 
  \li{Enum} Derive enum if all data type constructors are empty.
  \li{Object} Derive object if the type has a single non-empty constructor, and its parent \footnote{Type A is the parent type of type B if it has a field that refers to type B} is Object or Union. 
  \li{InputObject} Derive input object if the type has a single non-empty constructor, and its parent is InputObject or Field Arguments.
  \li{Union} Derive Union if the type has multiple constructors and its parent is Object or Union.
  \li{Fail} All other types are not supported.
\end{enumerate}
\end{frame}
