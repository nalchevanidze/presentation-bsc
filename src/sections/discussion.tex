\section{Discussion}


\begin{frame}\frametitle{Comparison}

    Other Haskell libraries provide more extensibility in schema definition than our approach. Besides, the argument chain definitions of the GraphQL API are more flexible than Haskell records for small sets of arguments. However, implementing resolvers for these schemas in our library is simpler because users receive more meaningful error messages, and field values are irrelevant. Besides, our approach is more intuitive and requires less experience than the type-level approach.
    
    There are other libraries in various languages that also have datatype-generic programming to derive GraphQL APIs. However, since we are using Haskell, we have automatically obtained Haskell's lazy and pure nature, which matches the lazy resolvable nature of GraphQL fields. This way, Haskell developers do not need to explicitly consider concurrency and laziness and focus on business logic. 
\end{frame}
    
\begin{frame}\frametitle{Advantages}

The presented approach successfully implements the requirements and provides:

\begin{itemize}
    \item easy-to-use interface while ensuring type safety.
    \item We preferred intuitive design over extensibility.
    \item The library can be learned quickly by beginners.
    \item Importing schemas from SDL facilitates quick starts and migration from other languages.
    \item A type-safe client package allows developers to implement entire applications in one language or even query data for resolvers from other GraphQL servers.
\end{itemize}

\end{frame}

\begin{frame}\frametitle{Limitations}

\begin{itemize}
    \item Haskell permits different naming of values and types than GraphQL. 
    \item sets and non-empty collections cannot be modeled in GraphQL because it provides only list types for collections. 
    \item mapping Haskell types requires support for input unions, which is not supported by GraphQL. 
    \item Haskell does not provide interfaces, so we do not yet have a satisfying way to support them. 
\end{itemize}

\end{frame}

\begin{frame}\frametitle{Outlook}

\begin{itemize}
    \li{Support Interfaces} representation of interfaces with "type guards" on unions. 
    \li{Type-Level Curried Arguments} flexible argument definitions for a small number of arguments than our current approach since the user does not have to define a new data type for each field. 
    \li{Custom Collections} Since GraphQL has only one type (List) for collections, we cannot represent collections with certain constraints. 
    \li{Support Directives}Since the GraphQL specification does not specify a particular implementation strategy for directives, it is up to each server library to provide a suitable API~\cite{schema-directives}.
    \li{Support Input Unions} GraphQL does not support input unions. While this function's value is essentially understood, its implementation is not cleared~\cite{gql-spec-input-unions}. 

\end{itemize}

\end{frame}