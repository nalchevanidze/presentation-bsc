\section{Discussion}

    
\begin{frame}[allowframebreaks]\frametitle{Discussion}

\begin{block}{Advantages}
\begin{itemize}
    \item The lazy and pure nature of Haskell frees developers from explicitly dealing with concurrency and laziness.
    \item easy-to-use interface while ensuring type safety.
    \item The library uses an intuitive design that can be quickly learned even by beginners.
    \item Importing schemas from SDL facilitates migration from other languages.
\end{itemize}
\end{block}

\begin{block}{Disadvantages}
\begin{itemize}
    \item Not all GraphQL names can be represented with Haskell types and values.
    \item Since we use algebraic data types and records, we lose extensibility.
\end{itemize}
\end{block}

\vspace{40pt}

Alternative GraphQL Haskell libraries provide a more extensible schema definition than our approach. However, implementing resolvers for these schemas in our library is more convenient. Besides, our approach is more intuitive and requires less experience.
    
\end{frame}

\begin{frame}\frametitle{Outlook}

\begin{itemize}
    \li{Support interfaces}  Haskell does not provide interfaces, so we do not yet fully support them.
    \li{Support custom collections} Sets and non-empty collections cannot be modeled in GraphQL because it provides only list types for collections.
    \li{Support directives} GraphQL specification does not specify a particular implementation strategy for directives.~\cite{schema-directives}.
    \li{Support input unions} GraphQL does not support input unions ~\cite{gql-spec-input-unions}.
\end{itemize}

\end{frame}