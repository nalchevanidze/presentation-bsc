\section{Discussion}


\begin{frame}\frametitle{Comparison}

    Other Haskell libraries provide more extensibility in schema definition than our approach. Besides, the argument chain definitions of the GraphQL API are more flexible than Haskell records for small sets of arguments. However, implementing resolvers for these schemas in our library is simpler because users receive more meaningful error messages, and field values are irrelevant. Besides, our approach is more intuitive and requires less experience than the type-level approach.
    
    There are other libraries in various languages that also have datatype-generic programming to derive GraphQL APIs. However, since we are using Haskell, we have automatically obtained Haskell's lazy and pure nature, which matches the lazy resolvable nature of GraphQL fields. This way, Haskell developers do not need to explicitly consider concurrency and laziness and focus on business logic. 
\end{frame}
    
\begin{frame}\frametitle{Advantages}

The presented approach successfully implements the requirements and provides:

\begin{itemize}
    \item easy-to-use interface while ensuring type safety.
    \item We preferred intuitive design .
    \item The library uses an intuitive design that can be quickly learned even by beginners.
    \item Importing schemas from SDL facilitates quick starts and migration from other languages.
    \item A type-safe client package allows developers to implement entire applications in one language or even query data for resolvers from other GraphQL servers.
\end{itemize}

\end{frame}

\begin{frame}\frametitle{Limitations}

\begin{itemize}
    \item Not all GrapHQL names can be represented with Haskell types and values.
    \item Since we use algebraic data types and records, we lose extensibility.
\end{itemize}

\end{frame}

\begin{frame}\frametitle{Outlook}

\begin{itemize}
    \li{Support interfaces}  Haskell does not provide interfaces, so we do not yet fully support them. One possible way is to support them with "type guards." 
    \li{Support custom collections} sets and non-empty collections cannot be modeled in GraphQL because it provides only list types for collections.  
    \li{Support directives} Since the GraphQL specification does not specify a particular implementation strategy for directives, it is up to each server library to provide a suitable API~\cite{schema-directives}.
    \li{Support input unions} GraphQL does not support input unions. While this function's value is essentially understood, its implementation is not cleared~\cite{gql-spec-input-unions}. 

    % \li{Type-Level Curried Arguments} flexible argument definitions for a small number of arguments than our current approach since the user does not have to define a new data type for each field. 
\end{itemize}

\end{frame}