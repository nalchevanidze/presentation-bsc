\section{Requirements}

\begin{frame}[allowframebreaks]\frametitle{Requirements}  

\begin{block}{Maintainability}

Maintainable software can adapt to continuous changes~\cite{requirements-change-1,view-of-web, sof-sus-institute-maintainability}.

% It allows developers to quickly: fix bugs, add a new feature or increase performance without introducing new bugs

\begin{itemize}

    \li{Low boilerplate} Boilerplate code increases maintenance costs for large programs~\cite{scrap-your-boilerplate}.

    \li{Familiarity} Maintainability depends on who maintains it~\cite{contr-reduce-maintainability}. Even newcomers have to be considered.

    \li{Modularity} 
    The loose coupling between modules and the high cohesion within a module improves maintainability~\cite{arc-modularity}. The reusable type and resolver definitions. 
    
\end{itemize}
\end{block}

\begin{block}{Reliability}

\begin{itemize}
    \li{Type safety} successfully compiled typed programs do not fail at runtime~\cite{milner-well-typed,wadler-well-typed}.  \textbf{deterministic derivation}, \textbf{resolver Validity}, \textbf{schema Validity}
    
    \li{Complience with GraphQL specifications} a GraphQL server that is not specification compliant will cause runtime errors for third-party applications.
\end{itemize}

\end{block}

\begin{block}{Efficiency}
The library must be lazy and avoid known Haskell functions, libraries, or types that can be a significant performance problem.
\end{block}

\end{frame}