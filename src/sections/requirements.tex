\section{Requirements}

\begin{frame}\frametitle{Requirements}  

\begin{alertblock}{Maintainability}

Maintainable software can adapt to the many changes occurring during software development.~\cite{requirements-change-1,view-of-web, sof-sus-institute-maintainability}

% It allows developers to quickly: fix bugs, add a new feature or increase performance without introducing new bugs

\begin{itemize}

    \li{Low boilerplate} Boilerplate code is tedious to write, easy to get wrong, and prone to change, increasing maintenance costs for large programs with dozens of data types~\cite{scrap-your-boilerplate}.

    \li{Familiarity} Maintainability depends a lot on who maintains it~\cite{contr-reduce-maintainability}. To allow developers with no less Haskell experience to maintain the API seamlessly, we want to avoid using new symbols and high-level concepts.

    \li{Modularity} 
    The loose coupling between modules and the high cohesion within a module lead to improved maintainability.  Furthermore, too many modules are just as undesirable as too few since it increases integration effort~\cite{arc-modularity}.
    The reusable type and resolver definitions. 
    
\end{itemize}
\end{alertblock}
\end{frame}

\begin{frame}\frametitle{Requirements}  

\begin{alertblock}{Reliability}

Reliability describes the probability that a product will operate trouble-free for a specified period under specified conditions~\cite{optimal-release-time}.

\begin{itemize}
    \li{Type Safety}: successfully compiled typed programs do not fail at runtime~\cite{milner-well-typed,wadler-well-typed}.  
    \begin{itemize}
        \li{deterministic derivation} the library must always derive the same GraphQL API representation for the same Haskell definitions. 
        \li{Resolver Validity} resolved values must meet its types. 
        \li{Schema Validity} schema representation generated by Haskell must be valid in GraphQL.
    \end{itemize}

    \li{Complience with GraphQL Specifications} a GraphQL server that is not specification compliant will not meet client expectations, resulting in runtime errors for third-party applications and low reliability.

\end{itemize}
\end{alertblock}
\end{frame}

\begin{frame}\frametitle{Requirements}  

\begin{alertblock}{Efficiency} 

The library must be lazy. The library must facilitate the writing of resolvers without running into n+1 selects problems. we only require avoiding known Haskell features, libraries, or types that can pose a significant performance problem.

\end{alertblock}

\end{frame}