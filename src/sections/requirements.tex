\section{Requirements}
\begin{frame}\frametitle{Requirements}

\begin{alertblock}{Maintainability}  

more than sixty percent  of the cost is spent on maintenance~\cite{maintainability-metrics,role-of-readability,maintainability-current-trends, readability-props}.

Software development is a dynamic process where many requirements change during the development of a software project~\cite{requirements-change-1,sof-sus-institute-maintainability}.
Maintainable software can adapt to these changes. It allows developers to quickly: fix bugs, add a new feature or increase performance without introducing new bugs~\cite{view-of-web, sof-sus-institute-maintainability}.

\begin{itemize}
    \item Low boilerplate: High maintenance costs are associated with the difficulty of reading and understanding programming code~\cite{role-of-readability,readability-props}. Readability can be affected by boilerplate code. Boilerplate code is tedious to write and easy to get wrong. It is also vulnerable to change. For example, if the scheme changes, any algorithm based on it must also change. This is not a big problem for small programs, but for large programs with dozens of data types, the maintenance cost can be increased~\cite{scrap-your-boilerplate}.
    Therefore, we require redundancy eliminations. In other words, the compiler must automatically derive and generate trivial parts that do not rely on additional user interaction.
    \item Familiarity: Maintainability depends a lot on who maintains it.  A team with much experience with a particular system will be able to maintain it more easily~\cite{contr-reduce-maintainability}. However, our goal is to enable both an experienced developer and a novice who does not have much experience maintaining the API seamlessly. Therefore, we want to avoid using new symbols and high-level concepts that the user needs to acquire to build, read or modify API.
    \item Modularity: Modularity, apart from scoping rules and separate compilation, also means breaking a problem into parts and composing solutions~\cite{history-of-haskell}. Therefore, we require modularity in two contexts: the library architecture and the API definition approach. 
    First, the modularity of the software architecture significantly influences maintainability. The loose coupling between modules and the high cohesion within a module lead to improved maintainability.  Furthermore, too many modules are just as undesirable as too few since it increases integration effort~\cite{arc-modularity}. 
    Second, the API definition approach must provide writing modular code to reuse type and resolver definitions between mutations, subscriptions, and queries. 
    
\end{itemize}

\end{alertblock}

\begin{alertblock}{Reliability}

Reliability describes the probability that a product will operate trouble-free for a specified period under specified conditions~\cite{optimal-release-time}.

\begin{itemize}
    \item Type Safety: successfully compiled typed programs do not fail at runtime~\cite{milner-well-typed,wadler-well-typed}.  Accordingly, we can achieve high reliability by using a type system that avoids runtime errors by reporting them at compile time. Therefore, we define four criteria for type safety: deterministic derivation, resolver validity, schema validity, type-safe subscriptions.  
    The first criterion, deterministic derivation, states that the library must always derive the same GraphQL API representation for the same Haskell definitions. 
    Furthermore, Resolver Validity asks questions 
    about whether resolved values meet its schema types. 
    Schema Validity asks if schema representation generated by Haskell is valid in GraphQL. Type-safe subscriptions ask if the types used by mutation and subscription conform.
    \item Complience with GraphQL Specifications:
    A key advantage of GraphQL is that the server and client can be built by different development teams using different languages~\cite{gql-healthcare}. 
    This is ensured by the compliance of the different implementations with the specifications. a GraphQL server that is not specification compliant will not meet client expectations, resulting in runtime errors for third-party applications and low reliability. Therefore, we require a high level of compliance with GraphQL specifications.
\end{itemize}

\end{alertblock}


\begin{alertblock}{Efficiency} 
  
Although GraphQL automatically solves over-fetching and under-fetching for client applications. 
It shifts the responsibility for solving these problems to the backend.  
The library must provide a lazy querying algorithm, which only executes the code necessary for the query. 
The library must facilitate the writing of resolvers 
without running into n+1 selects 
problems. Besides, since it is difficult to measure efficiency, we only require avoiding known Haskell features, libraries, or types that can pose a significant performance problem.

\end{alertblock}

\end{frame}