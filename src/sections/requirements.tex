\section{Requirements}
\begin{frame}\frametitle{Requirements}

\begin{alertblock}{Maintainability}  

Software development is a dynamic process where many requirements change~\cite{requirements-change-1,sof-sus-institute-maintainability}. Maintainable software can adapt to these changes. It allows developers to quickly: fix bugs, add a new feature or increase performance without introducing new bugs~\cite{view-of-web, sof-sus-institute-maintainability}.

\begin{itemize}

    \li{Low boilerplate} Boilerplate code is tedious to write and easy to get wrong. It is also vulnerable to change. This is not a big problem for small programs, but for large programs with dozens of data types, the maintenance cost can be increased~\cite{scrap-your-boilerplate}.

    \li{Familiarity} Maintainability depends a lot on who maintains it~\cite{contr-reduce-maintainability}. To allow developers with no less Haskell experience to maintain the API seamlessly, we want to avoid using new symbols and high-level concepts.

    \li{Modularity} Modularity, apart from scoping rules and separate compilation, also means breaking a problem into parts and composing solutions~\cite{history-of-haskell}. Therefore, we require modularity in two contexts: the library architecture and the API definition approach. 
    First, the modularity of the software architecture significantly influences maintainability. The loose coupling between modules and the high cohesion within a module lead to improved maintainability.  Furthermore, too many modules are just as undesirable as too few since it increases integration effort~\cite{arc-modularity}. 
    Second, the API definition approach must provide writing modular code to reuse type and resolver definitions between mutations, subscriptions, and queries. 
    
\end{itemize}

\end{alertblock}

\begin{alertblock}{Reliability}

Reliability describes the probability that a product will operate trouble-free for a specified period under specified conditions~\cite{optimal-release-time}.

\begin{itemize}
    \item Type Safety: successfully compiled typed programs do not fail at runtime~\cite{milner-well-typed,wadler-well-typed}.  Accordingly, we can achieve high reliability by using a type system that avoids runtime errors by reporting them at compile time. Therefore, we define four criteria for type safety: deterministic derivation, resolver validity, schema validity, type-safe subscriptions.  
    The first criterion, deterministic derivation, states that the library must always derive the same GraphQL API representation for the same Haskell definitions. 
    Furthermore, Resolver Validity asks questions 
    about whether resolved values meet its schema types. 
    Schema Validity asks if schema representation generated by Haskell is valid in GraphQL. Type-safe subscriptions ask if the types used by mutation and subscription conform.
    \item Complience with GraphQL Specifications:
    A key advantage of GraphQL is that the server and client can be built by different development teams using different languages~\cite{gql-healthcare}. 
    This is ensured by the compliance of the different implementations with the specifications. a GraphQL server that is not specification compliant will not meet client expectations, resulting in runtime errors for third-party applications and low reliability. Therefore, we require a high level of compliance with GraphQL specifications.
\end{itemize}

\end{alertblock}


\begin{alertblock}{Efficiency} 
  
Although GraphQL automatically solves over-fetching and under-fetching for client applications. 
It shifts the responsibility for solving these problems to the backend.  
The library must provide a lazy querying algorithm, which only executes the code necessary for the query. 
The library must facilitate the writing of resolvers 
without running into n+1 selects 
problems. Besides, since it is difficult to measure efficiency, we only require avoiding known Haskell features, libraries, or types that can pose a significant performance problem.

\end{alertblock}

\end{frame}