%!TEX root = ../../main.tex

\newcommand{\li}[1]{\item \textcolor{black}{\textbf{#1}}:}


\section{Mapping Rules}

The underlying entity of every GraphQL schema is a type. 
Thereby there are six types of named type definitions 
(Scalar, Object, Interface, Union, Enum, Input) 
and two wrapping types (List, Non-Null)~\cite{gql-spec}. 

\begin{frame}
\begin{itemize}

  \item Positional Constructors
  % GraphQL does not support unnamed products; its type fields must always have names~\cite{gql-spec}. 
  % However, Haskell does. That why we assume that a constructor without field selectors is enumerated like an array in the GraphQL context. 
  % Based on this assumption, fields of \expr{Cons1} and \expr{Cons2} \seeHS{positional-cons} are equal (in GraphQL context) and derive the same representation. 
  
  % \importHS{morpheus/code}{positional-cons}{
  %   Positional Constructors
  % }

  \item Unit Type

  % Various programming languages support unit types. The unit type indicates the absence of a specific value and serves as a placeholder when no other value exists or is needed~\cite{fsharp-unit}. Haskell introduces it as a type \expr{()} with a single possible value \expr{()}.  GraphQL does not provide it~\cite{gql-spec}. Therefore, we introduce it as an enum type \expr{Unit} containing only an alternative \expr{Unit}. \refGQL{unit-type} provides GraphQL definition of it.

  % \importGQL{morpheus/code}{unit-type}{
  %   GraphQL Unit Type Definition
  % }

\end{itemize}
\end{frame}

\subsection{Wrapping Types}
\begin{frame}

GraphQL defines two primitive wrapping types: List and Non-Null~\cite{gql-spec}. In the Haskell context, they can be interpreted as a type with a single type parameter.
\begin{itemize}

  \item Non-Null: Maybe
    %  GraphQL types are nullable by default: e.g., a scalar string can return either zero or a string value. Accordingly, the non-null type wraps another type and means that the resulting value will never be null~\cite{gql-spec}.

    to represent the nullable GraphQL type \expr{Int} in Haskell, we use \expr{Maybe Int}; and for the non-null GraphQL type \expr{Int!} we use the Haskell type \expr{Int}.

  \item List: List
  % GraphQL List is a collection of homogeneous elements, where the elements are ordered and serialized according to their type~\cite{gql-spec}. Since there is no difference, We can directly represent it with Haskell List.
\end{itemize}

\end{frame}

\subsection{Scalars}
\begin{frame}\frametitle{Scalars}

Scalar types represent primitive leaf values in a GraphQL type system. They can be represented as Strings (or other primitive values). GraphQL offers built-in scalar types like Int, Float, String, Boolean, and ID. However, the user can extend the type system with additional scalars with their semantic meaning~\cite{gql-spec}.

Since scalar types have no structural representation, we will impose no restriction and allow any type to represent a scalar type if it has appropriate parse and serialization methods.

\begin{itemize}

  \item Int:
  %  This scalar type represents a signed numeric 
    32-bit non-fractional value~\cite{gql-spec}. 

  \item Float: Double
  %  GraphQL-Float represents signed fractions with double precision~\cite{gql-spec}

  \item String: Text
  %  GraphQL String is a regular UTF-8 string for text data~\cite{gql-spec}. Haskell represents strings through the built-in list type. It allows the programmer to use the polymorphic list combinations for complex string manipulations.
  % However, it is also extremely inefficient. An alternative to String is the type Text, which is an array-based string representation that is faster and more compact than String~\cite{string-vs-text,string-types-alexeyshmalko,string-types-fpcomplete,hackage-data-text}. 
  \item Boolean: Bool
  % Since this represents typical Boolean values (true and false)~\cite{gql-spec}, it is represented as a type Bool.
  \item ID:  ID 
  % is a unique identifier that should always be serialized as a String (although it is often numeric)~\cite{gql-spec}. Accordingly, we declare a new data type ID with parse and serialization implementations that meet this specification.
\end{itemize}

\end{frame}

\subsection{Enums}

\begin{frame}\frametitle{Enums}

Besides scalar types, enum types are leaf values too, but in contrast, they describe the set of possible independent, unique values~\cite{gql-spec}. they are disjoint alternatives without inner values, so they correspond to the algebraic data type with empty fields. Note that the type is only represented as an enum if all its constructors are empty.

\importHS{enum}{GraphQL Enum}
\importGQL{enum}{GraphQL Enum}

\end{frame}

\begin{frame}\frametitle{Objects}

\subsection{Input Objects}

A GraphQL input object is a set of input fields, 
where input fields can be either 
scalars, enums, or other input objects~\cite{gql-spec}. 
In terms of Haskell, they resemble single constructor records. 
Therefore we will use them for representation.  Note that only the types with a single constructor are represented as input objects.

\importHS{input-object}{GraphQL Input Object in Haskell}
\importGQL{input-object}{}

\subsection{Objects}

\end{frame}

\begin{frame}\frametitle{Objects}

GraphQL objects are a set of named fields, where fields themselves consist of argument and return type~\cite{gql-spec}. Hence before we try to define an object, we will define its components.

Object field arguments are a set of all possible argument names with corresponding input types~\cite{gql-spec}. Since they are structurally no different from input objects, we can also represent them with Haskell records. 

% Object fields are functions which occasionally accept arguments and return corresponding values. An object field without an argument (e.g. \expr{field: Int}) is equivalent to a function with empty arguments (e.g. \expr{field(): Int})~\cite{gql-spec}.
% Accordingly, we represent Haskell functions as object fields with arguments and leftovers as fields without arguments. 

We represent the object types with records. Furthermore, they get the type parameter \expr{m} for modularity.
This technique allows types to be defined independently of the resolver operations, and the concrete operations can be passed recursively from parent to child. 

\importHS{object-type}{GraphQL Object in Haskell}
\importGQL{object-type}{}

\end{frame}

\subsection{Unions}
\begin{frame}\frametitle{Unions}

GraphQL unions represent an object, one of the possible alternative object types, but do not provide guaranteed fields between them~\cite{gql-spec}. This definition is very similar to the definition of algebraic data types, but Haskell presents it in different ways. While in GraphQL, we only refer to the object type in the list of possible types, in Haskell, we put each of them into a specific constructor. Furthermore, in Haskell, we can create alternative objects only with constructors without defining their types.

% we can generate GraphQL object types \expr{Cat} and \expr{Dog} for the two constructors of the data type \expr{Animal} and build a GraphQL union type from them. However, it raises difficulties if some member type is already defined.

% \importHS{morpheus/code}{union}{Mapping GraphQL Union}

% Let us assume one may want to define a union type animal with variants dog and cat, where the type dog is already defined. 
% \refHS{union-mixed} defines the variant dog with a single field positional constructor and the variant cat with a record constructor.
% However, we get the union type with packed variants \expr{UnionDog | Cat} instead of the expected \expr{Dog | Cat}. The approach creates a new object type \expr{UnionDog} for the variant dog instead of referencing it directly. So we must someway unpack type \expr{Dog} from it.

% \importHS{morpheus/code}{union-mixed}{Mapping GraphQL Union}

\importHS{union-unpack}{Union Types}
\importGQL{union-unpack}{Union Types}

% On the one hand, we could unpack single field constructors where a field type is an object, but that does not work because the constructor \expr{Cat} also has a single field \expr{name} with the object type \expr{Name}.  On the other hand, we could unpack single-field constructors with a name prefixed with "Unpack," but that would allow multiple unpacking of the same type in a single union. Therefore, we unpack constructors, where the name is the concatenation of the type constructor name and the referencing type name. That way, the compiler in \refHS{union-unpack} unpacks the type \expr{Dog} but generates a new object type \expr{Cat}.

% So far, we have only covered alternatives 
% with at least one field, but we also have 
% to deal with empty variants. 
% For example, one might want to add support 
% cases of unidentified animals without having 
% information about these species \seeHS{union-empty-cons}. 
% The current derivation approach presents 
% empty constructors as empty object definitions, 
% but GraphQL does not support empty object 
% definitions~\cite{gql-spec}. 
% To represent them as valid object definitions, 
% we can assign them a field \expr{\_} with the 
% type \expr{Unit}, which indicates that 
% the field does not contain any information 
% and reduces confusion . 
% As a result, \refHS{union-empty-cons} generates the schema defined in \refGQL{union-empty-cons}. As we can see, the GraphQL object \expr{Cat} represents the constructor \expr{Cat}, and the GraphQL object \expr{Unidentified} with only the field \expr{\_} represents the empty constructor \expr{Unidentified}. 


% \subsection{Interfaces}
% \label{sec:mapping:interfaces}

% As in object, interfaces represent a list of named fields and their arguments. Therefore the same rules apply to their fields as to object fields. Apart from their similarities, there are two main differences. First, an object can implement interfaces, which requires that the object type defines all fields defined by these interfaces. Second, an interface cannot implement another interface~\cite{gql-spec}.

% Haskell has no features like GraphQL interfaces. We can consider type classes as GraphQL interfaces, but they cannot be derived with generics, and we cannot cast them for additional fields in the GraphQL query. Accordingly, our current approach only simulates them and derives them like objects.

\end{frame}

\begin{frame}\frametitle{Determining GraphQL Types in Haskell}
\subsection{Determining GraphQL Types in Haskell}

So far, we have only covered the mapping of GraphQL types to corresponding Haskell types. However, we have not yet addressed how the approach decides which GraphQL type to derive from the Haskell data type.  This section presents the following rules that the compiler applies for a given execution order to achieve deterministic derivation.

\begin{enumerate}
  \li{Scalar, Wrapper, Interface} The structure of these types does not provide sufficient information to determine their kinds.Therefore they must explicitly provide associated kinds that determine their GraphQL type representation. The remaining types can be automatically derived based on their data type structure and place of use.
  
  \li{Field Arguments} Derive field arguments if the type is used as an argument of the object field. 

  \li{Enum} Derive enum if all data type constructors are empty.

  \li{Object} Derive object if the type has a single non-empty constructor, and its parent \footnote{Type A is the parent type of type B if it has a field that refers to type B} is Object or Union. 
  
  \li{InputObject} Derive input object if the type has a single non-empty constructor, and its parent is InputObject or Field Arguments.

  \li{Union} Derive Union if the type has multiple constructors and its parent is Object or Union.

  \li{Fail} All other types are not supported. The compiler will fail at this point. Note: The real implementation also supports the case of deriving input unions. However, since GraphQL does not support them, they are not mentioned in this work.

\end{enumerate}

\end{frame}
