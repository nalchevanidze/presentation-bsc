@book{entity-framework,
  author    = {Lerman, Miller},
  year      = {2011},
  title     = {{Programming Entity Framework: Code First: Creating and Configuring Data Models from Your Classes}},
  isbn      = {978-1449312947},
  publisher = {O’Reilly Media, Inc}
}


@inproceedings{rest-vs-gql-controlled-experiment,
  author = {Brito, Gleison and Valente, Marco},
  year   = {2020},
  month  = {02},
  pages  = {},
  title  = {REST vs GraphQL: A Controlled Experiment},
  doi    = {10.1109/ICSA47634.2020.00016},
  url    = {https://www.researchgate.net/publication/339413273_REST_vs_GraphQL_A_Controlled_Experiment}
}

@inproceedings{migrating-to-gql,
  author = {Brito, Gleison and Mombach, Thais and Valente, Marco},
  year   = {2019},
  month  = {01},
  pages  = {},
  title  = {Migrating to GraphQL: A Practical Assessment},
  doi    = {10.1109/SANER.2019.8667986},
  url    = {https://www.researchgate.net/publication/330563526_Migrating_to_GraphQL_A_Practical_Assessment}
}

@online{gql-healthcare,
  author = {Mukhiya, Suresh and Rabbi, Fazle and Pun, Ka I Violet and Rutle, Adrian and Lamo, Yngve},
  year   = {2019},
  month  = {08},
  pages  = {},
  title  = {A GraphQL approach to Healthcare Information Exchange with HL7 FHIR},
  url    = {https://www.researchgate.net/publication/334988948_A_GraphQL_approach_to_Healthcare_Information_Exchange_with_HL7_FHIR}
}

@article{real-time-sys-arc-based-on-gql,
  author  = {Guo, Ying and Deng, Fang and Yang, Xiudong},
  year    = {2018},
  month   = {12},
  pages   = {012015},
  title   = {Design and Implementation of Real-Time Management System Architecture based on GraphQL},
  volume  = {466},
  journal = {IOP Conference Series: Materials Science and Engineering},
  doi     = {10.1088/1757-899X/466/1/012015},
  url     = {https://www.researchgate.net/publication/329971350_Design_and_Implementation_of_Real-Time_Management_System_Architecture_based_on_GraphQL}
}

@article{gql-iot,
  author  = {Khan, Raees and Mian, Adnan},
  year    = {2020},
  month   = {03},
  pages   = {564},
  title   = {Sustainable IoT Sensing Applications Development through GraphQL-Based Abstraction Layer},
  volume  = {9},
  journal = {Electronics},
  doi     = {10.3390/electronics9040564}
}

@article{gql-and-classic-web-services,
  author = {Rey, Olivier},
  year   = {2017},
  month  = {09},
  pages  = {},
  title  = {GraphQL And Classic Web Services},
  url    = {https://www.researchgate.net/publication/337293844_GraphQL_And_Classic_Web_Services}
}


@article{efficient-data–communication,
  author = {Gustavsson, Stenlund},
  year   = {2016},
  month  = {06},
  pages  = {},
  title  = {Efficient data communication between a webclient and a cloud environment},
  url    = {https://lup.lub.lu.se/luur/download?func=downloadFile&recordOId=8885754&fileOId=8885760}
}

@mastersthesis{gql-on-graph-db,
  author  = {Linn Masson},
  title   = {Implementing the GraphQL Interface on top of a Graph Database},
  school  = {Linköping University},
  year    = 2020
}

@article{gql-jbpm,
  author  = {Bc. Dominik Hanák},
  year    = {2019},
  journal = {Masaryk University | Faculty of Informatics},
  title   = {Master’s thesis: GraphQL as modern access to jBPM process engine}
}

@inproceedings{initial-analysis-of-gql,
  author = {Hartig, Olaf},
  year   = {2017},
  month  = {06},
  pages  = {},
  title  = {An Initial Analysis of Facebook's GraphQL Language}
}

@inproceedings{semantically-enriched-open-api,
  author = {Mainas, Nikolaos and Petrakis, Euripides and Sotiriadis, Stelios},
  year   = {2017},
  month  = {11},
  pages  = {66-69},
  title  = {Semantically enriched open API service descriptions in the Cloud},
  doi    = {10.1109/ICSESS.2017.8342865}
}

@inproceedings{open-api-to-semantic-spec,
  author = {Schwichtenberg, Simon and Gerth, Christian and Engels, Gregor},
  year   = {2017},
  month  = {05},
  pages  = {},
  title  = {From Open API to Semantic Specifications and Code Adapters},
  doi    = {10.1109/ICWS.2017.56},
  url    = {{https://www.researchgate.net/publication/316653033_From_Open_API_to_Semantic_Specifications_and_Code_Adapters}}
}

@article{implementing-rpc,
  author  = {Birrell, Andrew and Nelson, Bruce},
  year    = {1984},
  month   = {02},
  pages   = {39-},
  title   = {Implementing Remote Procedure Calls},
  volume  = {2},
  journal = {ACM Transactions on Computer Systems},
  doi     = {10.1145/2080.357392}
}

@article{distributed-algorithms-usung-rpc,
  author = {Bal, H.E. and Van Renesse, Robbert and Tanenbaum, Andrew},
  year   = {1990},
  month  = {05},
  pages  = {},
  title  = {Implementing Distributed Algorithms Using Remote Procedure Calls}
}

@article{batch-mode-rpc,
  author  = {Uddin, Tomig and Haque, Md. Majharul},
  year    = {2020},
  month   = {09},
  pages   = {107-116},
  title   = {Batch mode RPC with Timing Effects (BMRPCTE)},
  volume  = {38},
  journal = {Jahangirnagar University Journal of Biological Sciences}
}

@inproceedings{web-service-to-json-rpc,
  author  = {Samsel, Christian and Gökay, Sevket and Heiniz, Paul and Krempels, Karl-Heinz},
  year    = {2013},
  month   = {07},
  pages   = {},
  title   = {Web service to JSON-RPC transformation},
  journal = {ICSOFT 2013 - Proceedings of the 8th International Joint Conference on Software Technologies},
  doi     = {10.5220/0004499502140219}
}

@inbook{uml-mapping-to-gql,
  author = {Rodriguez-Echeverria, Roberto and Canovas Izquierdo, Javier and Cabot, Jordi},
  year   = {2018},
  month  = {02},
  pages  = {149-155},
  title  = {Towards a UML and IFML Mapping to GraphQL},
  isbn   = {978-3-319-74432-2},
  doi    = {10.1007/978-3-319-74433-9_13},
  url    = {{https://www.researchgate.net/publication/323312824_Towards_a_UML_and_IFML_Mapping_to_GraphQL}}
}

@inbook{oasgraph,
  author = {Wittern, Erik and Cha, Alan and Laredo, Jim},
  year   = {2018},
  month  = {09},
  pages  = {65-83},
  title  = {Generating GraphQL-Wrappers for REST(-like) APIs},
  isbn   = {978-3-319-91661-3},
  doi    = {10.1007/978-3-319-91662-0_5}
}


@article{morph-gql-1,
  author  = {Chaves-Fraga, David and Priyatna, Freddy and Alobaid, Ahmad and Corcho, Oscar},
  year    = {2020},
  month   = {07},
  pages   = {1-19},
  title   = {Exploiting Declarative Mapping Rules for Generating GraphQL Servers with Morph-GraphQL},
  volume  = {30},
  journal = {International Journal of Software Engineering and Knowledge Engineering},
  doi     = {10.1142/S0218194020400070}
}

@inproceedings{morph-gql-2,
  author = {Priyatna, Freddy and Chaves-Fraga, David and Alobaid, Ahmad and Corcho, Oscar},
  year   = {2019},
  month  = {07},
  pages  = {},
  title  = {morph-GraphQL: GraphQL Servers Generation from R2RML Mappings},
  doi    = {10.18293/SEKE2019-055}
}

@inproceedings{gql-prolog,
  author  = {Nogatz, Falco and Seipel, Dietmar},
  year    = {2016},
  month   = {09},
  pages   = {42-56},
  title   = {Implementing GraphQL as a Query Language for Deductive Data\-bases in SWI-Prolog Using DCGs, Quasi Quotations, and Dicts},
  volume  = {234},
  journal = {Workshop on (Constraint) Logic Programming (WLP 2016)},
  doi     = {10.4204/EPTCS.234.4}
}

@article{why-fp-matters,
  author  = {Hughes, J.},
  title   = {{Why Functional Programming Matters}},
  journal = {The Computer Journal},
  volume  = {32},
  number  = {2},
  pages   = {98-107},
  year    = {1989},
  month   = {01},
  issn    = {0010-4620},
  doi     = {10.1093/comjnl/32.2.98},
  url     = {https://doi.org/10.1093/comjnl/32.2.98}
}

@unpublished{higher-order-plus-polymorphic,
  author   = {Simon Thompson},
  title    = {Higher-order + {P}olymorphic {=} {R}eusable},
  month    = {May},
  year     = {1997},
  pages    = {182-196},
  keywords = {determinacy analysis, Craig interpolants},
  note     = {},
  doi      = {},
  url      = {http://www.cs.kent.ac.uk/pubs/1997/224}
}

@inproceedings{history-of-haskell,
  author    = {Peyton Jones, Simon},
  title     = {A History of Haskell: being lazy with class},
  booktitle = {The Third ACM SIGPLAN History of Programming Languages Conference (HOPL-III)},
  year      = {2007},
  month     = {06},
  url       = {https://www.microsoft.com/en-us/research/publication/a-history-of-haskell-being-lazy-with-class/},
  edition   = {The Third ACM SIGPLAN History of Programming Languages Conference (HOPL-III)}
}

@misc{a-transformation-system-for-developing-recursive-programs,
  author = {R. M. Burstall and John Darlington},
  title  = {A Transformation System for Developing Recursive Programs},
  year   = {1977}
}


@book{ai-foundations,
  author  = {Poole, David and Mackworth, Alan},
  year    = {2010},
  month   = {01},
  title   = {Artificial Intelligence - Foundations of Computational Agents.},
  isbn    = {978-0-521-51900-7},
  journal = {Artificial Intelligence: Foundations of Computational Agents},
  doi     = {10.1017/CBO9780511794797}
}

@book{intro-to-algorithms,
  author  = {Cormen, Leiserson, Rivest and  Stein},
  year    = {2009},
  title   = {Introduction to Algorithms Third Edition},
  journal = {MIT Press}
}

@inproceedings{pj1997-type-classes,
  author    = {Peyton Jones, Simon and Jones, Mark and Meijer, Erik},
  title     = {Type classes: an exploration of the design space},
  booktitle = {Haskell workshop},
  year      = {1997},
  month     = {January},
  abstract  = {When type classes were first introduced in Haskell they were regarded as a fairly experimental language feature, and therefore warranted a fairly conservative design. Since that time, practical experience has convinced many programmers of the benefits and convenience of type classes. However, on occasion, these same programmers have discovered examples where seemingly natural applications for type class overloading are prevented by the restrictions imposed by the Haskell design.

It is possible to extend the type class mechanism of Haskell in various ways to overcome these limitations, but such proposals must be designed with great care. For example, several different extensions have been implemented in Gofer. Some of these, particularly the support for multi-parameter classes, have proved to be very useful, but interactions between other aspects of the design have resulted in a type system that is both unsound and undecidable. Another illustration is the introduction of constructor classes in Haskell 1.3, which came without the proper generalization of the notion of a context. As a consequence, certain quite reasonable programs are not typable.

In this paper we review the rationale behind the design of Haskell's class system, we identify some of the weaknesses in the current situation, and we explain the choices that we face in attempting to remove them.},
  url       = {https://www.microsoft.com/en-us/research/publication/type-classes-an-exploration-of-the-design-space/},
  edition   = {Haskell workshop}
}

@inproceedings{type-classes-in-hs,
  author    = {Hammond, K and Jones, SL Peyton and Wadler, PL and Hall, CV and Peyton Jones, Simon},
  title     = {Type classes in Haskell},
  booktitle = {ACM Transactions on Programming Languages and Systems, European Symposium on Programming (ESOP'94)},
  year      = {1994},
  month     = {April},
  abstract  = {This paper defines a set of type inference rules for resolving overloading introducted by type classes. Programs including type classes are transformed into ones which may be typed by the Hindley-Milner inference rules. In contrast to an other work on type classes, the rules presented here relate directly to user programs. An innovative aspect of this work in the use of second-order lambda calculus to record type information in the program.},
  publisher = {Springer Verlag LNCS 788},
  url       = {https://www.microsoft.com/en-us/research/publication/type-classes-in-haskell/},
  pages     = {241-256},
  volume    = {18},
  edition   = {ACM Transactions on Programming Languages and Systems, European Symposium on Programming (ESOP'94)}
}

@article{trees-that-grow,
  author   = {Najd, Shayan and Peyton Jones, Simon},
  title    = {Trees that grow},
  year     = {2017},
  month    = {January},
  abstract = {We study the notion of extensibility in functional data types, as a new approach to the problem of decorating abstract syntax trees with additional information. We observed the need for such extensibility while redesigning the data types representing Haskell abstract syntax inside Glasgow Haskell Compiler (GHC).

Specifically, we describe a programming idiom that exploits type-level functions to allow a particular form of extensibility.  The approach scales to support existentials and generalised algebraic data types, and we can use pattern synonyms to make it quite convenient in practice.},
  url      = {https://www.microsoft.com/en-us/research/publication/trees-that-grow/},
  pages    = {47-62},
  journal  = {Journal of Universal Computer Science (JUCS)},
  volume   = {23},
  chapter  = {1}
}

@inproceedings{essence-of-fp,
  author    = {Philip Wadler},
  title     = {The Essence of Functional Programming},
  booktitle = {},
  year      = {1992},
  pages     = {1--14},
  publisher = {Prentice Hall}
}

@inproceedings{haxl-fb-paper,
  author    = {Marlow, Simon and Brandy, Louis and Coens, Jonathan and Purdy, Jon},
  title     = {There is No Fork: An Abstraction for Efficient, Concurrent, and Concise Data Access},
  year      = {2014},
  isbn      = {9781450328739},
  publisher = {Association for Computing Machinery},
  address   = {New York, NY, USA},
  url       = {https://doi.org/10.1145/2628136.2628144},
  doi       = {10.1145/2628136.2628144},
  abstract  = {We describe a new programming idiom for concurrency, based on Applicative Functors, where concurrency is implicit in the Applicative <*> operator. The result is that concurrent programs can be written in a natural applicative style, and they retain a high degree of clarity and modularity while executing with maximal concurrency. This idiom is particularly useful for programming against external data sources, where the application code is written without the use of explicit concurrency constructs, while the implementation is able to batch together multiple requests for data from the same source, and fetch data from multiple sources concurrently. Our abstraction uses a cache to ensure that multiple requests for the same data return the same result, which frees the programmer from having to arrange to fetch data only once, which in turn leads to greater modularity.While it is generally applicable, our technique was designed with a particular application in mind: an internal service at Facebook that identifies particular types of content and takes actions based on it. Our application has a large body of business logic that fetches data from several different external sources. The framework described in this paper enables the business logic to execute efficiently by automatically fetching data concurrently; we present some preliminary results.},
  booktitle = {Proceedings of the 19th ACM SIGPLAN International Conference on Functional Programming},
  pages     = {325–337},
  numpages  = {13},
  keywords  = {haskell, distributed, applicative, concurrency, monad, data-fetching},
  location  = {Gothenburg, Sweden},
  series    = {ICFP '14}
}

@article{monad-trans-mae,
  author  = {Schrijvers, Tom and Piróg, Maciej and Wu, Nicolas and Jaskelioff, Mauro},
  title   = {Monad transformers and modular algebraic effects: what binds them together},
  doi     = {10.1145/3331545.3342595},
  url     = {https://www.fceia.unr.edu.ar/~mauro/pubs/haskell2019.pdf},
  urldate = {2021-01-02},
  year    = {2019},
  journal = {Proceedings of the 12th ACM SIGPLAN International Symposium on Haskell  - Haskell 2019}
}

@inproceedings{type-level-servant,
  author = {Mestanogullari, Alp and Hahn, Sönke and Arni, Julian and Löh, Andres},
  year   = {2015},
  month  = {08},
  pages  = {1-12},
  title  = {Type-level web APIs with Servant: an exercise in domain-specific generic programming},
  doi    = {10.1145/2808098.2808099}
}

@book{book-mythology,
  author    = {Grant, Hazel},
  title     = {Who's who in Classical Mythology},
  year      = 2002,
  publisher = {Psychology Press}
}

@article{mythology-1,
  author  = {Ntaidou, T. K. and Siempos, I. I.},
  month   = {07},
  pages   = {22-27},
  title   = {The Art of Providing Anaesthesia in Greek Mythology},
  doi     = {10.1177/0310057x120400s105},
  volume  = {40},
  year    = {2012},
  journal = {Anaesthesia and Intensive Care}
}

@article{mythology-2,
  author  = {Athanasiadis, Loukas},
  month   = {12},
  pages   = {781-782},
  title   = {Greek mythology and medical and psychiatric terminology},
  doi     = {10.1192/pb.21.12.781},
  url     = {https://www.cambridge.org/core/journals/psychiatric-bulletin/article/greek-mythology-and-medical-and-psychiatric-terminology/0DFDE62AC200B402A09B0DF90994F1CE},
  urldate = {2021-01-11},
  volume  = {21},
  year    = {1997},
  journal = {Psychiatric Bulletin}
}

@inproceedings{lw-ext-records,
  author       = {Jones, Mark P and Peyton Jones, Simon},
  title        = {Lightweight Extensible Records for Haskell},
  organization = {ACM},
  booktitle    = {Haskell Workshop},
  year         = {1999},
  month        = {October},
  abstract     = {In early versions of Haskell, the only direct way to construct values of user-defined datatypes was by applying a constructor function to an appropriate sequence of arguments, and the only direct way to extract component values was by pattern matching. Both rely on a positional notation for datatype components, which is awkward and error-prone when dealing with datatypes that have more than a couple of components. To remedy some of these problems, later versions of Haskell introduced a mechanism for labeled fields that allows components to be set and extracted by using the name of an associated selector function. While this has been useful in practice, it also has several significant problems. For example, record types are not lightweight because they must be declared before values of those types can be constructed. More seriously, no field name can be used in more than one datatype.

In this paper, we present a concrete proposal for replacing the labeled field mechanisms of Haskell with a more flexible system of records that avoids the problems described above. With a theoretical foundation in the earlier work of Gaster and Jones, our system offers lightweight, extensible records and a complement of polymorphic operations for manipulating them. On a more concrete level, our proposal is a direct descendent of the Trex implementation ("typed records with extensibility") in Hugs, but freed from the constraints of that setting, where compatibility with Haskell 98 was a major concern.},
  publisher    = {ACM},
  url          = {https://www.microsoft.com/en-us/research/publication/lightweight-extensible-records-for-haskell/},
  note         = {Paris}
}


@inproceedings{string-vs-text,
  author    = {Harper, Thomas},
  editor    = {Moraz{\'a}n, Marco T.
and Scholz, Sven-Bodo},
  title     = {Stream Fusion on Haskell Unicode Strings},
  booktitle = {Implementation and Application of Functional Languages},
  year      = {2010},
  publisher = {Springer Berlin Heidelberg},
  address   = {Berlin, Heidelberg},
  pages     = {125--140},
  abstract  = {Prior papers have presented a fusion framework called stream fusion for removing intermediate data structures from both lists and arrays in Haskell. Stream fusion is unique in using an explicit datatype to accomplish fusion. We demonstrate how this can be exploited in the creation of a new Haskell string representation Text, which achieves better performance and data density than String. Text uses streams not only to accomplish fusion, but also as a way to abstract away from various underlying representations. This allows the same set of combinators to manipulate Unicode text that is stored in a variety of ways.},
  isbn      = {978-3-642-16478-1}
}

@article{poly-ext-records,
  author = {Gaster, Benedict},
  year   = {1997},
  month  = {01},
  pages  = {},
  title  = {Polymorphic extensible records for haskell}
}

@article{hlist,
  author  = {Kiselyov, Oleg and Lämmel, Ralf and Schupke, Keean},
  year    = {2004},
  month   = {01},
  pages   = {96-107},
  title   = {Strongly typed heterogeneous collections},
  isbn    = {1-58113-850-4},
  journal = {Proceedings of the ACM SIGPLAN 2004 Haskell Workshop, Haskell'04},
  doi     = {10.1145/1017472.1017488}
}

@inproceedings{comparing-generic-approaches,
  author    = {Hinze, Ralf
and Jeuring, Johan
and L{\"o}h, Andres},
  editor    = {Backhouse, Roland
and Gibbons, Jeremy
and Hinze, Ralf
and Jeuring, Johan},
  title     = {Comparing Approaches to Generic Programming in Haskell},
  booktitle = {Datatype-Generic Programming},
  year      = {2007},
  publisher = {Springer Berlin Heidelberg},
  address   = {Berlin, Heidelberg},
  pages     = {72--149},
  abstract  = {The last decade has seen a number of approaches to datatype-generic programming: PolyP, Functorial ML, `Scrap Your Boilerplate', Generic Haskell, `Generics for the Masses', and so on. The approaches vary in sophistication and target audience: some propose full-blown programming languages, some suggest libraries, some can be seen as categorical programming methods. In these lecture notes we compare the various approaches to datatype-generic programming in Haskell. We introduce each approach by means of example, and we evaluate it along different dimensions (expressivity, ease of use, and so on).},
  isbn      = {978-3-540-76786-2}
}

@inproceedings{optimizing-generics,
  author  = {Magalhães, José and Holdermans, Stefan and Jeuring, Johan and Löh, Andres},
  year    = {2010},
  month   = {01},
  pages   = {33-42},
  title   = {Optimizing Generics Is Easy!},
  journal = {Proceedings of the ACM SIGPLAN Symposium on Partial Evaluation and Semantics-Based Program Manipulation},
  doi     = {10.1145/1706356.1706366}
}

@techreport{derivable-type-classes,
  author   = {Hinze, Ralf and Peyton Jones, Simon},
  title    = {Derivable type classes},
  series   = {Technical Reports},
  year     = {2000},
  month    = {September},
  abstract = {Generic programming allows you to write a function once, and use it many times at different types. A lot of good foundational work on generic programming has been done. The goal of this paper is to propose a practical way of supporting generic programming within the Haskell language, while going "with the grain" of the language.

On the way, we came across a separate issue, concerning type-class overloading where higher kinds are involved. We propose a simple type-system extension to allow the programmer to write richer contexts than is currently possible.},
  url      = {https://www.microsoft.com/en-us/research/publication/derivable-type-classes/},
  edition  = {Proceedings of the 2000 Haskell Workshop, Montreal},
  number   = {NOTTCS-TR-00-1},
  note     = {Proceedings of the Sixth Conference on Uncertainty in Artificial Intelligence (UAI1990)}
}

@inproceedings{meta-hs,
  author    = {Sheard, Tim and Peyton Jones, Simon},
  title     = {Template meta-programming for Haskell},
  booktitle = {Proceedings of the 2002 Haskell Workshop, Pittsburgh},
  year      = {2002},
  month     = {October},
  abstract  = {We propose a new extension to the purely functional programming language Haskell that supports compile-time meta-programming. The purpose of the system is to support the algorithmic construction of programs at compile-time.

The ability to generate code at compile time allows the programmer to implement such features as polytypic programs, macro-like expansion, user directed optimization (such as inlining), and the generation of supporting data structures and functions from existing data structures and functions.

Our design is being implemented in the Glasgow Haskell Compiler, ghc.

&nbsp;},
  url       = {https://www.microsoft.com/en-us/research/publication/template-meta-programming-for-haskell/},
  pages     = {1-16},
  edition   = {Proceedings of the 2002 Haskell Workshop, Pittsburgh}
}

@inproceedings{mu-hs-acm,
  author    = {Serrano, Alejandro and Corpa, Flavio},
  title     = {Describing Microservices Using Modern Haskell (Experience Report)},
  year      = {2020},
  isbn      = {9781450380508},
  publisher = {Association for Computing Machinery},
  address   = {New York, NY, USA},
  url       = {https://doi.org/10.1145/3406088.3409018},
  doi       = {10.1145/3406088.3409018},
  abstract  = {We present Mu, a domain specific language to describe and develop microservices in Haskell. At its core, Mu provides a type level representation of schemas, which we leverage in various ways. These schemas can be automatically imported from industry-standard interface definition languages.  Mu uses many of the type level extensions to GHC, and techniques such as (data type) generic programming and attribute grammars. Apart from the description of the library, we discuss a series of shortcomings in current GHC/Haskell, mostly related to the friendliness of the exposed library interface once complex types enter the scene.},
  booktitle = {Proceedings of the 13th ACM SIGPLAN International Symposium on Haskell},
  pages     = {1–8},
  numpages  = {8},
  keywords  = {Haskell, type level programming, type classes, microservices},
  location  = {Virtual Event, USA},
  series    = {Haskell 2020}
}

@inbook{datatype-generic-programming,
  author = {Gibbons, Jeremy},
  year   = {2007},
  month  = {11},
  pages  = {1-71},
  title  = {Datatype-Generic Programming},
  volume = {4719},
  doi    = {10.1007/978-3-540-76786-2_1}
}

@inproceedings{wadler-well-typed,
  author    = {Wadler, Philip
and Findler, Robert Bruce},
  editor    = {Castagna, Giuseppe},
  title     = {Well-Typed Programs Can't Be Blamed},
  booktitle = {Programming Languages and Systems},
  year      = {2009},
  publisher = {Springer Berlin Heidelberg},
  address   = {Berlin, Heidelberg},
  pages     = {1--16},
  abstract  = {We introduce the blame calculus, which adds the notion of blame from Findler and Felleisen's contracts to a system similar to Siek and Taha's gradual types and Flanagan's hybrid types. We characterise where positive and negative blame can arise by decomposing the usual notion of subtype into positive and negative subtypes, and show that these recombine to yield naive subtypes. Naive subtypes previously appeared in type systems that are unsound, but we believe this is the first time naive subtypes play a role in establishing type soundness.},
  isbn      = {978-3-642-00590-9}
}

@article{milner-well-typed,
  author  = {Robin Milner},
  title   = {A theory of type polymorphism in programming},
  journal = {Journal of Computer and System Sciences},
  year    = {1978},
  volume  = {17},
  pages   = {348--375}
}

@inproceedings{scrap-your-boilerplate,
  author    = {Lämmel, Ralf and Peyton Jones, Simon},
  title     = {Scrap your boilerplate: a practical approach to generic programming},
  booktitle = {ACM SIGPLAN International Workshop on Types in Language Design and Implementation (TLDI'03)},
  year      = {2003},
  month     = {January},
  abstract  = {We describe a design pattern that for writing programs that traverse data structures built from rich mutually-recursive data types. Such programs often have a great deal of "boilerplate" code that simply walks the structure, hiding a small amount of "real" code that constitutes the reason for the traversal.

Our technique allows most of this boilerplate to be written once and for all (perhaps even mechanically generated), leaving the programmer free to concentrate on the important part of the algorithm. These generic programs are much more robust to data structure evolution because they contain many fewer lines of type-specific code.

Our approach is simple to understand, reasonably efficient, and it handles all the data types found in conventional functional programming languages. It makes essential use of rank-2 polymorphism, an extension found in some implementations of Haskell.

 	PowerPoint slides},
  publisher = {ACM Press},
  url       = {https://www.microsoft.com/en-us/research/publication/scrap-your-boilerplate-a-practical-approach-to-generic-programming/},
  pages     = {26-37},
  edition   = {ACM SIGPLAN International Workshop on Types in Language Design and Implementation (TLDI'03)}
}

@article{role-of-readability,
  author = {Collar, Emilio and Valerdi, Ricardo},
  year   = {2014},
  month  = {01},
  pages  = {},
  title  = {Role of Software Readability on Software Development Cost}
}

@inproceedings{readability-props,
  author = {Karanikiotis, Thomas and Papamichail, Michail and Gonidelis, Ioannis and Karatza, Dimitra and Symeonidis, Andreas},
  year   = {2020},
  month  = {01},
  pages  = {61-72},
  title  = {A Data-driven Methodology towards Interpreting Readability against Software Properties},
  doi    = {10.5220/0009891000610072}
}

@inproceedings{maintainability-metrics,
  author = {Muthanna, S. and Kontogiannis, Kostas and Ponnambalam, Kumaraswamy and Stacey, B.},
  year   = {2000},
  month  = {02},
  pages  = {248 - 256},
  title  = {A maintainability model for industrial software systems using design level metrics},
  isbn   = {0-7695-0881-2},
  doi    = {10.1109/WCRE.2000.891476}
}

@article{maintainability-current-trends,
  author  = {Malhotra, Ruchika and Chug, Anuradha},
  year    = {2016},
  month   = {10},
  pages   = {1221-1253},
  title   = {Software Maintainability: Systematic Literature Review and Current Trends},
  volume  = {26},
  journal = {International Journal of Software Engineering and Knowledge Engineering},
  doi     = {10.1142/S0218194016500431}
}

@article{arc-modularity,
  author  = {Ghasemi, Morteza and Sharafi, Sayed and Arman, Ala},
  year    = {2015},
  month   = {04},
  pages   = {465-479},
  title   = {Towards an Analytical Approach to Measure Modularity in Software Architecture Design},
  volume  = {10},
  journal = {Journal of Software},
  doi     = {10.17706/jsw.10.4.465-479}
}

@article{contr-reduce-maintainability,
  author = {Al-Hagery, Mohammed},
  year   = {2012},
  month  = {09},
  pages  = {11-22},
  title  = {Contributors to Reduce Maintainability Cost at the Software Implementation Phase},
  volume = {3}
}


@inproceedings{edsl-modeling,
  author = {Bayol, Benoit and Chen, Yuting and Cournède, Paul-Henry},
  year   = {2013},
  month  = {07},
  pages  = {},
  title  = {Towards an EDSL to enhance good modelling practice for non-linear stochastic discrete dynamical models Application to plant growth models},
  doi    = {10.5220/0004481101320138}
}

@article{requirements-change-1,
  author  = {Sharif, Bushra and Shoab, A and Khan, and Bhatti, Muhammad},
  year    = {2012},
  month   = {05},
  pages   = {},
  title   = {Measuring the Impact of Changing Requirements on Software Project Cost: An Empirical Investigation},
  volume  = {9},
  journal = {International Journal of Computer Science Issues}
}

@article{view-of-web,
  author     = {Chen, Yingying and Mahajan, Ratul and Sridharan, Baskar and Zhang, Zhi-Li},
  title      = {A Provider-Side View of Web Search Response Time},
  year       = {2013},
  issue_date = {October 2013},
  publisher  = {Association for Computing Machinery},
  address    = {New York, NY, USA},
  volume     = {43},
  number     = {4},
  issn       = {0146-4833},
  url        = {https://doi.org/10.1145/2534169.2486035},
  doi        = {10.1145/2534169.2486035},
  abstract   = {Using a large Web search service as a case study, we highlight the challenges that modern Web services face in understanding and diagnosing the response time experienced by users. We show that search response time (SRT) varies widely over time and also exhibits counter-intuitive behavior. It is actually higher during off-peak hours, when the query load is lower, than during peak hours. To resolve this paradox and explain SRT variations in general, we develop an analysis framework that separates systemic variations due to periodic changes in service usage and anomalous variations due to unanticipated events such as failures and denial-of-service attacks. We find that systemic SRT variations are primarily caused by systemic changes in aggregate network characteristics, nature of user queries, and browser types. For instance, one reason for higher SRTs during off-peak hours is that during those hours a greater fraction of queries come from slower, mainly-residential networks. We also develop a technique that, by factoring out the impact of such variations, robustly detects and diagnoses performance anomalies in SRT. Deployment experience shows that our technique detects three times more true (operator-verified) anomalies than existing techniques.},
  journal    = {SIGCOMM Comput. Commun. Rev.},
  month      = aug,
  pages      = {243–254},
  numpages   = {12},
  keywords   = {search response time, performance monitoring, web services, anomaly detection and diagnosis}
}

@inproceedings{optimal-release-time,
  author    = {Sassenburg, Hans and Berghout, Egon},
  title     = {Optimal Release Time: Numbers or Intuition?},
  year      = {2006},
  isbn      = {1595933999},
  publisher = {Association for Computing Machinery},
  address   = {New York, NY, USA},
  url       = {https://doi.org/10.1145/1137702.1137714},
  doi       = {10.1145/1137702.1137714},
  abstract  = {Despite the exponential increase in the demand for software and the increase in our dependence on software, many software manufacturers behave in an unpredictable manner. In such an unpredictable software manufacturer organization, it is difficult to determine the optimal release time. An economic model is presented supporting the evaluation and comparison of different release or market entry alternatives. This model requires information with respect to achieved reliability and maintainability. Existing literature reveals many models to estimate reliability and limited models to estimate maintainability. The practicality of most available models is however criticized. A series of case studies confirmed that software manufacturers struggle with determining the reliability and maintainability of their products prior to releasing them. This leads to a combination of non-analytical methods to decide when a software product is 'good enough' for release: intuition prevails where sharing convincing information is required. Next research steps are put forward to investigate ways increasing the economic reasoning about the optimal release time.},
  booktitle = {Proceedings of the 2006 International Workshop on Software Quality},
  pages     = {57–62},
  numpages  = {6},
  keywords  = {software reliability prediction, optimal release time, software reliability estimation, maintainability},
  location  = {Shanghai, China},
  series    = {WoSQ '06}
}

@inproceedings{number-of-web-services,
  author = {Claro, Daniela and Licchelli, Oriana and Albers, Patrick and Macêdo, Raimundo},
  year   = {2008},
  month  = {01},
  pages  = {},
  title  = {Personalized Reliable Web service Compositions},
  volume = {427}
}

@inproceedings{ho-tlp,
  author    = {Kiss, Csongor and Eisenbach, Susan and Field, Tony and Peyton Jones, Simon},
  title     = {Higher-order type-level programming in Haskell},
  booktitle = {International Conference on Functional Programming (ICFP'19)},
  year      = {2019},
  month     = {August},
  publisher = {ACM},
  url       = {https://www.microsoft.com/en-us/research/publication/higher-order-type-level-programming-in-haskell/}
}